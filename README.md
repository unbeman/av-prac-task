# av-prac-task
Сервис динамического сегментирования пользователей. ТЗ от Авито


#### Билд и запуск сервиса в Docker'e:
- make dc-up 

#### Приложение:
- http://127.0.0.1:8080

#### Swagger UI:
- http://127.0.0.1:8080/swagger/index.html


### Что сделано:
- Основное задание
- Дополнительное задание 1
- Дополнительное задание 3
- Тесты на http handler'ы с mock базой
- Документирование кода


### Что использовалось:
- PostgreSQL для хранения данных
- GORM для работы с базой, в том числе миграций
- Chi для роутинга
- Swagger для генерации документации по API

### Основное задание
1. Метод создания сегмента был дополнен с учетом задания 3.
   - Если сегмент с заданным название уже существует в базе, даже если он помечен как удален, то создать сегмент с таким же названием не получится.
По Slug (названиям) построен уникальный индекс в базе.
2. Метод удаления сегмента был изменен с учетом задания 1. 
   - Сегменты не удаляются из базы данных, а помечаются как удаленные (выставляется время удаления deleted_at), и в то же время отношения пользователей к этому сегменту помечается как удаленные.
3. Метод добавления пользователя в сегмент.
   - Сегменты пользователей добавляются и удаляются в синхронном режиме. Так что пользователь ждет конца выполнения добавления/удаления в базе.
   - Также вместо полного удаления сегментов пользователя они лишь помечаются удаленными. 
4. Метод получения активных сегментов пользователя.
   - Формируется и возвращается список названий сегментов в которых состоит пользователь.

### Дополнительное задание 1 - сохранение истории операций по сегментам пользователя.
Для реализации задания, был написан пул воркеров, который асинхронно обрабатывает входящие по буферизированному каналу задачи на генерацию отчета по пользователю.
Соответственно пользователь не ждет пока отчет будет сформирован, а сразу получает ссылку по которой можно скачать отчет после окончания генерации.
Так как нам нужна полная история, то сегменты пользователя никогда не удаляются, а лишь помечаются как удаленные.
В дальнейшем можно создать крон для очистки базы от давно удаленных сегментов.

### Дополнительное задание 3 - автоматическое добавление пользователей в сегмент.
Сразу после создания нового сегмента (синхронно) выбирается пул пользователей которым добавляется новый сегмент.
Выборка происходит с использованием функции random() в самом запросе базы данных (что на самом деле достаточно медленно).
Это довольно длительный процесс, который в будущем лучше сделать асинхронным по примеру первого задания или с использованием брокера сообщений.


## Эндпоинты `/api/v1`

---
### `POST` `/segment` - Создание нового сегмента

Создает новый сегмент с заданным именем. Если задан процент пользователей `selection` [0, 1), то новый сегмент 
добавится случайно выбранным пользователям (в количестве зависящем от selection).
Если имя занято, то вернет ошибку.

Пример запроса:
```
curl -X 'POST' \
'http://127.0.0.1:8080/api/v1/segment' \
-H 'accept: application/json' \
-H 'Content-Type: application/json' \
-d '{
"selection": 0.2,
"slug": "AVITO_VOICE_MESSAGES"
}'
```
В случае успеха придет только статус `200 OK`

В случае неудачи вернется json c описанием ошибки и соответствующим HTTP кодом, например:

`409 Conflict`
```
{
"message": "segment with slug (AVITO_VOICE_MESSAGES) already exists"
}
```
---
### `DELETE` `/segment/{slug}` - Удаление сегмента

Помечает сегмент удаленным по заданному имени. Также помечает удаленным все отношения пользователей к этому сегменту.

Пример запроса:
```
curl -X 'DELETE' \
'http://127.0.0.1:8080/api/v1/segment/AVITO_VOICE_MESSAGES' \
-H 'accept: application/json'
```

В ответ придет только статус `200 OK`

Пример ответа с кодом ошибки `404 Not found`:

```
{
  "message": "segment with slug (AVITO_VOICE_MESSAGES) is not found for delete"
}
```

---
### `GET` `/segments/user/{user_id}` - Получение сегментов пользователя

Возвращает активные сегменты пользователя, которые не помечены как удаленные.

Пример запроса:
```
curl -X 'GET' \
'http://127.0.0.1:8080/api/v1/segments/user/10' \
-H 'accept: application/json'
```

Пример ответа `200 OK`:

```
[
"PROTECTED_PHONE_NUMBER",
"VOICE_MSG",
"PROMO_5"
]
```

---

### `POST` `/segments/user/{user_id}` - Обновление сегментов пользователя

Добавляет и удаляет сегменты пользователю по соответствующим спискам. Если названия сегментов пересекаются, то вернется ошибка. 
Если хотя бы один сегмент из списков в базе помечен как удаленный, то вернется ошибка.

Пример запроса:

```
curl -X 'POST' \
'http://127.0.0.1:8080/api/v1/segments/user/10' \
-H 'accept: application/json' \
-H 'Content-Type: application/json' \
-d '{
"segments_to_add": [
"PROTECTED_PHONE_NUMBER",
"VOICE_MSG"
],
"segments_to_delete": [
"PROMO_5"
]
}'
```

В случае успеха придет только статус `200 OK`

В случае неудачи вернется json c описанием ошибки и соответствующим HTTP кодом, например:

`404 NOT FOUND`
```
{
"message": "some segments not found"
}
```

---

### `GET` `/segments/user/{user_id}/csv` - Генерация истории пользователя

Возвращает ссылку на отчет по пользователю и заданному временному полуинтервалу.
Генерируется в асинхронном режиме.

```
curl -X 'GET' \
'http://127.0.0.1:8080/api/v1/segments/user/10/csv?from=2023-08-01&to=2023-08-31' \
-H 'accept: application/json'
```


Пример ответа `202 Accepted`:

```
{
"link": "127.0.0.1:8080/api/v1/segments/user/history/user-1_2023-08-01_2023-08-31.csv"
}
```

---

### `GET` `/segments/user/history/{filename}` - Получение файла по имени

Возвращает CSV файл с историей операций по сегментам пользователя.

```
curl -X 'GET' \
'http://127.0.0.1:8080/api/v1/segments/user/history/user-1_2023-08-01_2023-08-31.csv' \
-H 'accept: text/csv'
```

Пример ответа `200 OK`:
```
user_id,segment_slug,operation,date
1,AVITO_SALES_20,add,2023-08-30 02:02:39.725564 +0300 MSK
1,SEL-AUTOS,add,2023-08-30 01:22:13.408561 +0300 MSK
1,SEL-AUTOS,delete,2023-08-30 02:02:39.792499 +0300 MSK
1,SEL-AUTOS-1,add,2023-08-30 01:22:13.408561 +0300 MSK
1,SEL-AUTOS-1,delete,2023-08-30 02:02:39.792499 +0300 MSK
1,SEL-AUTOS-0.01,add,2023-08-02 02:02:39.725 +0300 MSK
1,AVITO_VOICE_MESSAGES,add,2023-08-02 02:02:39.725 +0300 MSK
```